<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combinational Functional Blocks</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }

        header {
            background-color: #4CAF50;
            /* color: white; */
            text-align: center;
            padding: 1em;
        }

        section {
            padding: 20px;
            background-color: white;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #333;
        }

        .decoder {
            margin-bottom: 40px;
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .alu {
            margin-bottom: 40px;
            align-items: center;
            gap: 40px;
        }

        .input-group,
        .output {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: gray;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
        }

        .active {
            background-color: limegreen;
        }

        img.circuit {
            max-width: 150px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        img.circuit-large {
            max-width: 250px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        img.circuit-larger {
            max-width: 350px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        
        img.truth-table {
            max-width: 400px;
            max-width: 600px;
        }
 
        img.truth-table-large {
            max-width: 600px;
        }

        img.truth-table-larger {
             max-width: 700px;
        }

        #sum_3bit_dec {
            font-weight: bold;
            font-size: larger;
            color: blue;
        }

        #sub_result_dec {
            font-weight: bold;
            font-size: larger;
            color: blue;
        }

        #as_result_dec {
            font-weight: bold;
            font-size: larger;
            color: blue;
        }

        pre {
            font-size: 18px;
            background-color: #f8f8f8;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            overflow-x: auto;
            line-height: 1.5;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 50px;
        }

        .binaryBar {
            display: flex;
            justify-content: flex-start;
            margin-bottom: 10px;
        }

        .bit {
            width: 40px;
            height: 40px;
            border: 1px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            background-color: white;
        }

        .progressContainer {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            margin-bottom: 20px;
        }

        .progressBar {
            width: 164px;
            height: 20px;
            border: 2px solid black;
            background-color: white;
            position: relative;
            margin-right: 10px;
        }

        .progressFill {
            height: 100%;
            background-color: lightgreen;
            width: 0%;
            transition: width 0.3s;
        }

        .decimalValue {
            font-size: 18px;
            min-width: 30px;
            text-align: left;
            font-weight: bold;
        }

        #buttonContainer,
        #animationButtonContainer {
            display: flex;
            justify-content: flex-start;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>

<body onload="initializeOutputs()">

    <header>
        <h1>Combinational Functional Blocks</h1>
        <h2>Mạch Tư Duy Chức Năng</h2>
    </header>

    <section id="intro">
        <p>Mạch tư duy tổ hợp (Combinational Logic Circuits) là loại cấu trúc mạch trong đó đầu ra của mạch là một hàm tư duy trực
            tiếp của các đầu vào tại cùng thời điểm.</p>
        <p>Đặc điểm chính của mạch tư duy tổng hợp:</p>
        <ul>
            <li>Được xây dựng từ các mạch tư duy cơ bản như: AND, OR, NOT, NAND, NOR, XOR, XNOR</li>
            <li>Đầu ra thay đổi ngay lập tức khi đầu vào thay đổi</li>
            <li>Không có bộ nhớ (memoryless)</li>
        </ul>
        <h2>Combinational Functional Blocks - Mạch Tư Duy Chức Năng</h2>
        <p>Mạch chức năng thông dụng được tạo nên từ mạch tư duy tổ hợp gồm:</p>
        <ul>
            <li>Mạch giải mã (decoder)</li>
            <li>Mạch mã hóa (encoder)</li>
            <li>Mạch chọn hay mạch điều kênh (multiplexer)</li>
            <li>Mạch phân tách hay mạch phân kênh (demultiplexer)</li>
            <li>Các mạch tính toán số học như mạch cộng, mạch trừ và mạch cộng trừ đa năng</li>
        </ul>
    </section>

    <section id="decoding">
        <h1>Mạch Giải Mã - <i>Decoder Circuits</i></h1>
        <p>Mạch giải mã (Decoder) là một loại mạch có chức năng chuyển đổi tín hiệu số nhị phân đầu vào (0: 00,
            1: 01, 2: 10, 3: 11) thành một
            dạng tín hiệu đầu ra riêng biệt (1000, 0100, 0010, 0001). Thông thường, mạch giải mã nhận vào n bit dữ liệu
            và kích hoạt đúng một
            trong số 2^n đầu ra dựa trên tổ hợp giá trị của các bit đầu vào.</p>
        <p>Mạch giải mã thường được sử dụng trong các ứng dụng như:</p>
        <ul>
            <li>Lựa chọn đường truyền trong bộ nhớ (memory addressing)</li>
            <li>Điều các thiết bị hiển thị (như LED, màn hình)</li>
        </ul>
        <p>Một số loại mạch giải mã phổ biến bao gồm:</p>
        <ul>
            <li>Mạch giải mã 2-ra-4 (2-to-4 decoder)</li>
            <li>Mạch giải mã 3-ra-8 (3-to-8 decoder)</li>
            <li>Mạch giải mã 4-ra-16 (4-to-16 decoder)</li>
        </ul>
        <p>Thông thường, mạch giải mã có thể có thêm chân <b>Enable</b> để bật hoặc tắt toàn bộ chức năng giải mã theo
            yêu cầu.
        </p>
        <h2>2-to-4 Line Decoder (No Enable)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>A <input type="checkbox" id="a_2to4" onchange="decode2to4()"></label>
                <label>B <input type="checkbox" id="b_2to4" onchange="decode2to4()"></label>
            </div>
            <img src="decode2to4.png" alt="2-to-4 Decoder without Enable" class="circuit">
            <div id="output_2to4" class="output"></div>
        </div>
        <img src="2_4_decoder_tb.jpg" alt="2-to-4 Decoder Truth Table" class="truth-table">

        <h2>2-to-4 Line Decoder (With Enable)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>EN <input type="checkbox" id="enable_2to4" onchange="decode2to4Enable()"></label>
                <label>A <input type="checkbox" id="a_2to4_en" onchange="decode2to4Enable()"></label>
                <label>B <input type="checkbox" id="b_2to4_en" onchange="decode2to4Enable()"></label>
            </div>
            <img src="decode2to4Enable.png" alt="2-to-4 Decoder with Enable" class="circuit-large">
            <div id="output_2to4_en" class="output"></div>
        </div>
        <img src="2-4withEn_tb.png" alt="2-to-4 Decoder with Enable Truth Table" class="truth-table-large">

        <h2>3-to-8 Line Decoder (No Enable)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>A <input type="checkbox" id="a_3to8" onchange="decode3to8()"></label>
                <label>B <input type="checkbox" id="b_3to8" onchange="decode3to8()"></label>
                <label>C <input type="checkbox" id="c_3to8" onchange="decode3to8()"></label>
            </div>
            <img src="decode3to8.png" alt="3-to-8 Decoder without Enable" class="circuit-larger">
            <div id="output_3to8" class="output"></div>
        </div>
        <img src="3_8_decoder_tb.jpg" alt="3-to-8 Decoder Truth Table" class="truth-table-larger">

        <h2>3-to-8 Line Decoder (With Enable)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>EN <input type="checkbox" id="enable_3to8" onchange="decode3to8Enable()"></label>
                <label>A <input type="checkbox" id="a_3to8_en" onchange="decode3to8Enable()"></label>
                <label>B <input type="checkbox" id="b_3to8_en" onchange="decode3to8Enable()"></label>
                <label>C <input type="checkbox" id="c_3to8_en" onchange="decode3to8Enable()"></label>
            </div>
            <img src="decode3to8Enable.png" alt="3-to-8 Decoder with Enable" class="circuit-large">
            <div id="output_3to8_en" class="output"></div>
        </div>
    </section>

    <section id="encoding">
        <h1>Mạch Mã Hóa - <i>Encoder Circuits</i></h1>
        <p>Mạch mã hóa (Encoder) là một mạch có chức năng trái ngược với mạch giải mã (Decoder). Nó được dùng để
            mã hóa các tính hiệu đầu vào thành tính hiệu số nhị
            phân đầu ra.Thông thường, một mạch mã hóa có 2<sup>n</sup> đầu vào và n đầu ra. Ví dụ, một mạch mã hóa 8-3
            sẽ có 8 tín hiệu đầu vào và 3 tín hiệu đầu ra, biểu diễn mã nhị phân của đầu vào đang được kích hoạt.</p>
        <p>Tuy nhiên, trong thực tế, có thể xảy ra trường hợp nhiều đầu vào cùng được kích hoạt cùng lúc. Để xử lý vấn
            đề này, người ta thiết kế <b>mạch mã hóa ưu tiên (Priority Encoder)</b>. Trong mạch mã hóa ưu tiên, nếu có
            nhiều
            đầu vào đồng thời ở mức "1", mạch sẽ tự động ưu tiên tín hiệu đầu vào có thứ tự cao hơn</p>
        <p>Ngoài ra, nhiều mạch mã hóa còn bổ sung một đầu ra đặc biệt gọi là chân <b>Validity (V)</b>, hay còn gọi là
            chân hợp
            lệ. Chân này có nhiệm vụ báo hiệu rằng có ít nhất một đầu vào đang được kích hoạt. Nếu tất cả các đầu vào
            đều ở mức "0", chân V sẽ ở mức "0" để báo rằng không có đầu vào hợp lệ; ngược lại, nếu có đầu vào được kích
            hoạt, chân V sẽ ở mức "1".</p>

        <p>Ứng dụng của mạch mã hóa:</p>
        <ul>
            <li>Bàn phím số: Khi một phím được nhấn, mạch mã hóa sẽ chuyển tín hiệu từ phím đó thành mã nhị phân
                gửi cho bộ xử lý.</li>
            <li>Xử lý tính hiệu cảm biến: Trong các hệ thống cảm biến, mạch mã hóa được sử dụng để đọc vị trí,
                tốc độ hoặc các trạng thái khác.</li>
            <li>Thiết kế hệ thống giao tiếp số: Giảm số lượng dây dẫn cần thiết khi truyền tải nhiều tín hiệu.
            </li>
        </ul>

        <h2>8-to-3 Priority Encoder (with Valid Output)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>D0 <input type="checkbox" id="d0_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D1 <input type="checkbox" id="d1_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D2 <input type="checkbox" id="d2_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D3 <input type="checkbox" id="d3_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D4 <input type="checkbox" id="d4_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D5 <input type="checkbox" id="d5_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D6 <input type="checkbox" id="d6_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D7 <input type="checkbox" id="d7_8to3p" onchange="priorityEncode8to3()"></label>
            </div>
            <img src="8_3_p_encoder_V.png" alt="8-to-3 Priority Encoder Circuit" class="circuit-larger">
            <div id="output_8to3p" class="output"></div>
        </div>
        <img src="encoder8to3tb.png" alt="8-to-3 Encoder Truth Table" class="truth-table-large">

    </section>

    <section id="multiplexer">
        <h1>Mạch chọn kênh - <i>Multiplexer Circuits</i></h1>
        <p>Mạch chọn hay mạch điều kênh (Multiplexer - viết tắt là MUX) là một loại mạch có chức năng chọn một trong nhiều
            tín hiệu đầu vào để truyền ra một đầu ra duy nhất. Mục tiêu của bộ chọn là gộp nhiều nguồn dữ liệu vào một
            đường truyền chung, từ đó giúp tiết kiệm số lượng dây dẫn và tối ưu hóa hệ thống mạch.</p>

        <p>Một bộ chọn thông thường có:
        <ul>
            <li>2<sup>n</sup> đầu vào dữ liệu (data inputs),</li>
            <li>n đầu vào chọn (select inputs) để xác định đầu vào nào sẽ được kết nối tới đầu ra,</li>
            <li>và 1 đầu ra duy nhất (output).</li>
        </ul>
        </p>

        <p>Ví dụ: Một bộ chọn 4-1 có 4 đầu vào dữ liệu (D0, D1, D2, D3), 2 đầu vào chọn (S1, S0), và 1 đầu ra (Y). Các
            đầu vào chọn S1, S0 sẽ quyết định tín hiệu từ đầu vào nào sẽ xuất hiện tại đầu ra, D0 hoặc D1 hoặc D2 hoặc
            D3.</p>

        <h2>4-to-1 Multiplexer</h2>
        <div class="decoder">
            <div class="input-group">
                <label>S0 <input type="checkbox" id="s0_mux" onchange="updateMuxOutput()"></label>
                <label>S1 <input type="checkbox" id="s1_mux" onchange="updateMuxOutput()"></label>
            </div>
            <div id="input_mux" class="output"></div>
            <img src="mux4to1.png" alt="4-to-1 Multiplexer" class="circuit-large">
            <div id="output_mux" class="output"></div>
            <div id="selected_input_label" style="text-align:center; margin-top:10px; font-weight:bold;"></div>
        </div>
        <img src="mux4to1tb.png" alt="4-to-1 Truth Table" style="max-width: 300px;">

        <h2>4-to-1 Multiplexer Logic Diagram</h2>
        <img src="mux4to1diag.png" alt="4-to-1 Multiplexer Diagram" style="max-width: 500px;">
    </section>

    <section id="demultiplexer">
        <h1>Mạch Phân Tách - <i>Demultiplexer Circuits</i></h1>
        <p>Mạch phân tách hay mạch phân kênh (Demultiplexer - viết tắt là DEMUX) là một loại mạch có chức năng nhận
            một tín hiệu đầu vào và phân phối tín hiệu đó tới một trong nhiều đầu ra. Bộ phân kênh thực hiện quá trình
            ngược lại so với bộ chọn (Multiplexer).</p>

        <p>Một bộ phân kênh thông thường có:
        <ul>
            <li>1 đầu vào dữ liệu (Data Input),</li>
            <li>n đầu vào chọn (Select Inputs) để quyết định tín hiệu sẽ được gửi đến đầu ra nào,</li>
            <li>và 2<sup>n</sup> đầu ra (Outputs).</li>
        </ul>
        </p>

        <p>Ví dụ: Một bộ phân kênh 1-4 có 1 đầu vào dữ liệu (D), 2 đầu vào chọn (S1, S0), và 4 đầu ra (Y0, Y1, Y2, Y3).
            Các tín hiệu tại đầu vào chọn S1 và S0 sẽ xác định đầu ra nào nhận dữ liệu từ đầu vào, D0 hoặc D1 hoặc D2
            hoặc
            D3.</p>

        <h2>1-to-4 Demultiplexer</h2>
        <div class="decoder">
            <div class="input-group">
                <label>S0 <input type="checkbox" id="s0_demux" onchange="updateDemuxOutput()"></label>
                <label>S1 <input type="checkbox" id="s1_demux" onchange="updateDemuxOutput()"></label>
            </div>
            <div id="input_demux" class="output"></div>
            <img src="demux1to4.png" alt="1-to-4 Demultiplexer" class="circuit-large">
            <div id="output_demux" class="output"></div>
        </div>
        <img src="demux1to4tb.png" alt="1-to-4 Demultiplexer Truth Table" style="max-width: 500px;">
        
        <h2>1-to-4 Demultiplexer Logic Diagram</h2>
        <img src="demux1to4diag.png" alt="1-to-4 Demultiplexer Diagram" style="max-width: 300px;">
    </section>

    <section if="adder">
        <h2>Mạch cộng (Adder)</h2>
        <p>Mạch cộng (Adder) là một mạch tổ hợp dùng để thực hiện phép cộng hai số nhị phân. Trong điện tử số, mạch cộng
            được sử dụng rất phổ biến trong các bộ xử lý, đơn vị tính tư duy số học (Arithmetic Logic Unic). </p>

        <p><i>Bên dưới
                mô
                phỏng số dương ở hệ nhị phân, bạn có thể nhấn "TĂNG" để thêm 1 giá trị cho nó</i>.</p>

        <!-- First bar set (with manual Increase/Decrease) -->
        <div id="binaryBar1" class="binaryBar">
            <!-- Squares will be created here -->
        </div>

        <div id="progressContainer1" class="progressContainer">
            <div id="progressBar1" class="progressBar">
                <div id="progressFill1" class="progressFill"></div>
            </div>
            <div id="decimalValue1" class="decimalValue">0</div>
        </div>

        <div id="buttonContainer">
            <button onclick="increase()">TĂNG</button>
        </div>

        <p><b>Mạch cộng đủ 1-bit (Full Adder)</b> là một mạch cơ bản để cầu tạo một mạch cộng nhiều bit. Mạch này có thể
            cộng hai bit với một bit nhớ từ phép tính trước đó. Trong thiết
            kế vi xử lý, các mạch cộng nhiều bit được mở rộng từ bộ cộng đủ 1-bit để tạo thành mạch cộng 4-bit, 8-bit,
            16-bit hoặc nhiều hơn. <b>Mạch cộng đủ
                1-bit</b> có ba đầu vào là A, B và C<sub>in</sub> (carry-in), và hai đầu ra là S (sum) và
            C<sub>out</sub>
            (carry-out).</p>

        <div class="decoder">
            <div class="input-group">
                <label>A <input type="checkbox" id="a_fa" onchange="updateFullAdder()"></label>
                <label>B <input type="checkbox" id="b_fa" onchange="updateFullAdder()"></label>
                <label>C<sub>in</sub> <input type="checkbox" id="cin_fa" onchange="updateFullAdder()"></label>
            </div>
            <img src="full-adder.png" alt="1-Bit Full Adder Circuit" class="circuit-large">
            <div id="output_fa" class="output"></div>
        </div>

        <p>Bảng chân trị của mạch cộng đủ 1-bit:</p>
        <table border="1" cellpadding="5">
            <tr>
                <th>A</th>
                <th>B</th>
                <th>C<sub>in</sub></th>
                <th>S</th>
                <th>C<sub>out</sub></th>
            </tr>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>1</td>
                <td>1</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>1</td>
                <td>0</td>
                <td>1</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>1</td>
                <td>1</td>
                <td>0</td>
                <td>1</td>
            </tr>
            <tr>
                <td>1</td>
                <td>0</td>
                <td>0</td>
                <td>1</td>
                <td>0</td>
            </tr>
            <tr>
                <td>1</td>
                <td>0</td>
                <td>1</td>
                <td>0</td>
                <td>1</td>
            </tr>
            <tr>
                <td>1</td>
                <td>1</td>
                <td>0</td>
                <td>0</td>
                <td>1</td>
            </tr>
            <tr>
                <td>1</td>
                <td>1</td>
                <td>1</td>
                <td>1</td>
                <td>1</td>
            </tr>
        </table>

        <p>Biểu thức logic:</p>
        <ul>
            <li>S = A ⊕ B ⊕ C<sub>in</sub></li>
            <li>C<sub>out</sub> = (A · B) + (C<sub>in</sub> · (A ⊕ B))</li>
        </ul>

        <p>Ví dụ: <b>Mạch cộng 3-bit (3-Bit Adder)</b></p>
        <p>Để cộng hai số nhị phân 3-bit, ta cần ghép nối ba mạch cộng đủ 1-bit (Full Adder - FA) liên tiếp như sau:</p>

        <ul>
            <li>Bit 0: Dùng một mạch cộng đủ để cộng A<sub>0</sub> và B<sub>0</sub> với C<sub>in</sub> = 0. Xuất ra
                S<sub>0</sub> và C<sub>out0</sub>.</li>
            <li>Bit 1: Dùng mạch cộng đủ thứ hai để cộng A<sub>1</sub> và B<sub>1</sub> với C<sub>in</sub> =
                C<sub>out0</sub>. Xuất ra S<sub>in</sub> và C<sub>out1</sub>.</li>
            <li>Bit 2: Dùng mạch cộng đủ thứ ba để cộng A<sub>2</sub> và B<sub>2</sub> với C<sub>in</sub> =
                C<sub>out1</sub>. Xuất ra S<sub>2</sub> và C<sub>out2</sub>.</li>
        </ul>

        <p>Đầu ra cuối cùng là một số nhị phân 4-bit gồm ba bit tổng (S<sub>2</sub>, S<sub>1</sub>, S<sub>0</sub>) và
            bit nhớ cuối (C<sub>out2</sub>) nếu có tràn số (overflow).
        </p>


        <h2>3-Bit Adder</h2>
        <div class="alu">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <label for="a_3bit"><b>A:</b></label>
                <select id="a_3bit" onchange="update3BitAdder()">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                </select>
                <div id="a_3bit_bin" style="display: flex; gap: 5px;"></div>
            </div>

            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <label for="b_3bit"><b>B:</b></label>
                <select id="b_3bit" onchange="update3BitAdder()">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                </select>
                <div id="b_3bit_bin" style="display: flex; gap: 5px;"></div>
            </div>

            <div style="margin: 10px 0;">
                <img src="adder3bit.png" alt="3-Bit Adder Circuit" class="circuit-larger" style="max-width: 600px;">
            </div>

            <div style="display: flex; align-items: center; gap: 10px;">
                <label><b>KẾT QUẢ (C<sub>out</sub> + S):</b> <span id="sum_3bit_dec">0</span></label>
                <div id="sum_3bit_bin" style="display: flex; gap: 5px;"></div>
            </div>
        </div>
    </section>

    <section if="adder">
        <h2>Mạch Trừ - <i>Subtractor</i></h2>
        <p>Mạch trừ (Subtractor) là một mạch được sử dụng để thực hiện phép trừ giữa hai số nhị
            phân. Thay vì thiết kế một mạch trừ hoàn toàn riêng biệt, trong thực tế các hệ thống số thường sử dụng
            <b>mạch cộng (Adder)</b> kết hợp với phép biểu diễn số âm bằng số <b>bù hai (2's complement)</b> để thực
            hiện phép trừ.
        </p>

        <p><i>Bên dưới
                mô
                phỏng số âm / dương ở hệ nhị phân, để biểu thị số âm, mượn thêm 1 bit để chứa số ở miền âm và các số ở miền âm được tính theo phương pháp bù hai, bạn có
                thể nhấn "TĂNG" để thêm 1 giá trị</i>.</p>

        <div id="binaryBar2" class="binaryBar"></div>

        <div id="progressContainer2" class="progressContainer">
            <div id="progressBar2" class="progressBar">
                <div id="progressFill2" class="progressFill"></div>
            </div>
            <div id="decimalValue2" class="decimalValue">0</div>
        </div>

        <div id="buttonContainer2">
            <button onclick="increase2()">TĂNG</button>
        </div>

        <h3>Nguyên lý trừ bằng phép bù hai</h3>
        <p>Thay vì trực tiếp tính A - B, ta sử dụng công thức:</p>
        <pre>
A - <b style="color: blue;"><i>B</i></b> = A + <b style="color: blue;"><i>(số bù 2 của B)</i></b>
</pre>
        <p>Trong hệ nhị phân, số bù hai của một số B được tính như sau:</p>
        <ol>
            <li>Đảo tất cả các bit của B (lấy bù một, <i>1’s complement</i>).</li>
            <li>Cộng thêm 1 vào kết quả để có bù hai.</li>
        </ol>

        <p>Khi đã có bù hai của B, ta cộng nó với A bằng mạch cộng thông thường (Full Adder). Kết quả nhận được chính là
            A - B.</p>
        <h2>4-Bit Subtractor (A - B)</h2>
        <div class="alu">

            <!-- A row -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <label for="a_sub"><b>A:</b></label>
                <select id="a_sub" onchange="update4BitSubtractor()">
                    <option value="-8">-8</option>
                    <option value="-7">-7</option>
                    <option value="-6">-6</option>
                    <option value="-5">-5</option>
                    <option value="-4">-4</option>
                    <option value="-3">-3</option>
                    <option value="-2">-2</option>
                    <option value="-1">-1</option>
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7" selected>7</option>
                </select>
                <div id="a_sub_bin" style="display: flex; gap: 5px;"></div>
            </div>

            <!-- B row -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <label for="b_sub"><b>B:</b></label>
                <select id="b_sub" onchange="update4BitSubtractor()">
                    <option value="-8">-8</option>
                    <option value="-7">-7</option>
                    <option value="-6">-6</option>
                    <option value="-5">-5</option>
                    <option value="-4">-4</option>
                    <option value="-3">-3</option>
                    <option value="-2">-2</option>
                    <option value="-1" selected>-1</option>
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                </select>
                <div id="b_sub_bin" style="display: flex; gap: 5px;"></div>
                <label><b>SỐ BÙ 2 CỦA B:</b></label>
                <div id="b_twos_comp_bin" style="display: flex; gap: 5px;"></div>
            </div>

            <!-- Diagram -->
            <div style="margin: 10px 0;">
                <img src="sub3bit.png" alt="4-Bit Subtractor Circuit" class="circuit-larger" style="max-width: 600px;">
            </div>

            <!-- Result -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <label><b>Carry Out:</b></label>
                <div id="sub_result_carry" style="display: flex; gap: 5px;"></div>
            </div>

            <div style="display: flex; align-items: center; gap: 10px;">
                <label><b>4-bit S:</b> <span id="sub_result_dec">0</span></label>
                <div id="sub_result_value" style="display: flex; gap: 5px;"></div>
                <div id="overflow_detect" style="display: flex;"></div>
            </div>
        </div>
        
        <i>Mạch trừ có thể có thêm chức năng nhận biết tràn số</i>
    </section>

    

    <section if="adder">
        <h2>Mạch Cộng Trừ Đa Năng - <i>Adder/Subtractor</i></h2>
        <p>Mạch cộng trừ đa năng (Adder/Subtractor) là một mạch tổ hợp có khả năng thực hiện cả phép cộng và phép trừ giữa hai
            số nhị phân. Thay vì sử dụng hai mạch riêng biệt, mạch cộng/trừ thực hiện hai phép toán một cách linh hoạt, chỉ thông qua một tín hiệu điều khiển. Để làm được việc này, mạch có:
        </p>

        <ul>
            <li>Một tín hiệu điều khiển gọi là <b>Subtract</b>:</li>
            <ul>
                <li>Khi <b>Subtract = 0</b>: thực hiện phép cộng (A + B)</li>
                <li>Khi <b>Subtract = 1</b>: thực hiện phép trừ (A - B)</li>
            </ul>
            <li>Các cổng XOR được sử dụng để chuyển đổi đầu vào B thành dạng bù hai khi thực hiện phép trừ.</li>
        </ul>

        <p>Mỗi bit của B sẽ đi qua một cổng XOR với tín hiệu Subtract. Nếu Subtract = 0, B không đổi. Nếu Subtract = 1, B bị đảo (tương
            đương với bước lấy bù một), sau đó tín hiệu Subtract cũng được đưa vào Carry-in ban đầu của bộ cộng để hoàn tất
            quá trình lấy bù hai.</p>
        <h2>4-Bit Adder/Subtractor</h2>
        <div class="alu">

            <!-- A input -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <label for="a_as"><b>A:</b></label>
                <select id="a_as" onchange="updateAdderSubtractor()" value="7">
                    <option value="-8">-8</option>
                    <option value="-7">-7</option>
                    <option value="-6">-6</option>
                    <option value="-5">-5</option>
                    <option value="-4">-4</option>
                    <option value="-3">-3</option>
                    <option value="-2">-2</option>
                    <option value="-1">-1</option>
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7" selected>7</option>
                </select>
                <div id="a_as_bin" style="display: flex; gap: 5px;"></div>
            </div>

            <!-- B input -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <label for="b_as"><b>B:</b></label>
                <select id="b_as" onchange="updateAdderSubtractor()" value="1">
                    <option value="-8">-8</option>
                    <option value="-7">-7</option>
                    <option value="-6">-6</option>
                    <option value="-5">-5</option>
                    <option value="-4">-4</option>
                    <option value="-3">-3</option>
                    <option value="-2">-2</option>
                    <option value="-1">-1</option>
                    <option value="0">0</option>
                    <option value="1" selected>1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                </select>
                <div id="b_as_bin" style="display: flex; gap: 5px;"></div>

                <!-- Two's complement of B (only when subtracting) -->
                <label id="b_as_twos_label"><b>SỐ BÙ 2 CỦA B:</b></label>
                <div id="b_as_twos" style="display: flex; gap: 5px;"></div>
            </div>

            <!-- Mode selector -->
            <div style="margin-bottom: 10px;">
                <label><input type="checkbox" id="mode_as" onchange="updateAdderSubtractor()"> Subtract (S)</label>
            </div>

            <!-- Diagram -->
            <div style="margin: 10px 0;">
                <img src="addsub4bit.png" alt="4-Bit Adder/Subtractor Circuit" class="circuit-larger"
                    style="max-width: 600px;">
            </div>

            <!-- Result -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <label><b>Carry Out:</b></label>
                <div id="as_carry" style="display: flex; gap: 5px;"></div>
            </div>

            <div style="display: flex; align-items: center; gap: 10px;">
                <label><b>KẾT QUẢ 4-bit S:</b> <span id="as_result_dec">0</span></label>
                <div id="as_result_bin" style="display: flex; gap: 5px;"></div>
                <div id="overflow_detect_as" style="display: flex;"></div>
            </div>
        </div>
        
        <i>Mạch cộng trừ đa năng có thể có thêm chức năng nhận biết tràn số</i>
    </section>
    
    <script>
        function updateCircles(containerId, activeIndex, totalOutputs) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            for (let i = 0; i < totalOutputs; i++) {
                const circle = document.createElement('div');
                circle.classList.add('circle');
                circle.innerText = i;
                if (i === activeIndex) {
                    circle.classList.add('active');
                }
                container.appendChild(circle);
            }
        }

        function decode2to4() {
            let a = document.getElementById('a_2to4').checked ? 1 : 0;
            let b = document.getElementById('b_2to4').checked ? 1 : 0;
            let index = (b << 1) | a;
            updateCircles('output_2to4', index, 4);
        }

        function decode2to4Enable() {
            let enable = document.getElementById('enable_2to4').checked;
            let a = document.getElementById('a_2to4_en').checked ? 1 : 0;
            let b = document.getElementById('b_2to4_en').checked ? 1 : 0;
            if (enable) {
                let index = (b << 1) | a;
                updateCircles('output_2to4_en', index, 4);
            } else {
                updateCircles('output_2to4_en', -1, 4);
            }
        }

        function decode3to8() {
            let a = document.getElementById('a_3to8').checked ? 1 : 0;
            let b = document.getElementById('b_3to8').checked ? 1 : 0;
            let c = document.getElementById('c_3to8').checked ? 1 : 0;
            let index = (c << 2) | (b << 1) | a;
            updateCircles('output_3to8', index, 8);
        }

        function decode3to8Enable() {
            let enable = document.getElementById('enable_3to8').checked;
            let a = document.getElementById('a_3to8_en').checked ? 1 : 0;
            let b = document.getElementById('b_3to8_en').checked ? 1 : 0;
            let c = document.getElementById('c_3to8_en').checked ? 1 : 0;
            if (enable) {
                let index = (c << 2) | (b << 1) | a;
                updateCircles('output_3to8_en', index, 8);
            } else {
                updateCircles('output_3to8_en', -1, 8);
            }
        }

        function priorityEncode8to3() {
            let inputs = [
                document.getElementById('d0_8to3p').checked,
                document.getElementById('d1_8to3p').checked,
                document.getElementById('d2_8to3p').checked,
                document.getElementById('d3_8to3p').checked,
                document.getElementById('d4_8to3p').checked,
                document.getElementById('d5_8to3p').checked,
                document.getElementById('d6_8to3p').checked,
                document.getElementById('d7_8to3p').checked
            ];
            let outputDiv = document.getElementById('output_8to3p');
            outputDiv.innerHTML = '';

            // Priority: D7 highest to D0 lowest
            let activeIndex = -1;
            for (let i = 7; i >= 0; i--) {
                if (inputs[i]) {
                    activeIndex = i;
                    break;
                }
            }

            let labels = ['A2', 'A1', 'A0', 'V'];
            if (activeIndex >= 0) {
                let binary = activeIndex.toString(2).padStart(3, '0');
                // Output circles for A2, A1, A0, V
                for (let i = 0; i < 3; i++) {
                    const circle = document.createElement('div');
                    circle.classList.add('circle');
                    circle.innerText = labels[i];
                    if (binary[2 - i] === '1') {
                        circle.classList.add('active');
                    }
                    outputDiv.appendChild(circle);
                }
                // Add V = 1
                const vCircle = document.createElement('div');
                vCircle.classList.add('circle', 'active');
                vCircle.innerText = labels[3];
                outputDiv.appendChild(vCircle);
            } else {
                // No active input
                for (let i = 0; i < 3; i++) {
                    const circle = document.createElement('div');
                    circle.classList.add('circle');
                    circle.innerText = labels[i];
                    outputDiv.appendChild(circle);
                }
                const vCircle = document.createElement('div');
                vCircle.classList.add('circle');
                vCircle.innerText = labels[3];
                outputDiv.appendChild(vCircle);
            }
        }

        let muxInputs = [0, 0, 0, 0];

        function startMuxInputOscillation() {
            setInterval(() => {
                muxInputs[0] ^= 1;
                updateMuxCircles();
                updateMuxOutput();
            }, 2000); // 0.5 Hz

            setInterval(() => {
                muxInputs[1] ^= 1;
                updateMuxCircles();
                updateMuxOutput();
            }, 500); // 1 Hz

            setInterval(() => {
                muxInputs[2] ^= 1;
                updateMuxCircles();
                updateMuxOutput();
            }, 250);

            setInterval(() => {
                muxInputs[3] ^= 1;
                updateMuxCircles();
                updateMuxOutput();
            }, 50);
        }

        function updateMuxCircles(selected = -1) {
            const inputContainer = document.getElementById('input_mux');
            inputContainer.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const circle = document.createElement('div');
                circle.classList.add('circle');
                circle.innerText = 'I' + i;
                if (muxInputs[i] === 1) {
                    circle.classList.add('active');
                }
                if (i === selected) {
                    //circle.style.backgroundColor = 'deepskyblue'; // Highlight selected input
                    circle.style.color = 'white';
                    circle.style.border = '6px solid red';
                }
                inputContainer.appendChild(circle);
            }
        }

        function updateMuxOutput() {
            let s1 = document.getElementById('s1_mux').checked ? 1 : 0;
            let s0 = document.getElementById('s0_mux').checked ? 1 : 0;
            let selectedInput = (s1 << 1) | s0;
            const yValue = muxInputs[selectedInput];

            const outputContainer = document.getElementById('output_mux');
            outputContainer.innerHTML = '';
            const yCircle = document.createElement('div');
            yCircle.classList.add('circle');
            yCircle.innerText = 'Y';
            if (yValue === 1) {
                yCircle.classList.add('active');
            }
            outputContainer.appendChild(yCircle);

            const selectedLabel = document.getElementById('selected_input_label');
            selectedLabel.innerText = `Selected input: I${selectedInput}`;

            updateMuxCircles(selectedInput); // <-- Pass selected input to highlight
        }

        let demuxInput = 0;

        function startDemuxInputOscillation() {
            setInterval(() => {
                demuxInput ^= 1;
                updateDemuxOutput();
            }, 250); // 2 Hz => toggle every 0.5s
        }

        function updateDemuxOutput() {
            let s1 = document.getElementById('s1_demux').checked ? 1 : 0;
            let s0 = document.getElementById('s0_demux').checked ? 1 : 0;
            let selectedOutput = (s1 << 1) | s0;

            // Update Input D
            const inputContainer = document.getElementById('input_demux');
            inputContainer.innerHTML = '';
            const dCircle = document.createElement('div');
            dCircle.classList.add('circle');
            dCircle.innerText = 'D';
            if (demuxInput === 1) {
                dCircle.classList.add('active');
            }
            inputContainer.appendChild(dCircle);

            // Update Outputs Y0, Y1, Y2, Y3
            const outputContainer = document.getElementById('output_demux');
            outputContainer.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const circle = document.createElement('div');
                circle.classList.add('circle');
                circle.innerText = 'Y' + i;
                if (i === selectedOutput && demuxInput === 1) {
                    circle.classList.add('active');
                }
                outputContainer.appendChild(circle);
            }
        }

        function updateFullAdder() {
            const a = document.getElementById('a_fa').checked ? 1 : 0;
            const b = document.getElementById('b_fa').checked ? 1 : 0;
            const cin = document.getElementById('cin_fa').checked ? 1 : 0;

            const sum = a ^ b ^ cin;
            const cout = (a & b) | (a & cin) | (b & cin);

            const outputContainer = document.getElementById('output_fa');
            outputContainer.innerHTML = '';

            const sumCircle = document.createElement('div');
            sumCircle.classList.add('circle');
            sumCircle.innerText = 'S';
            sumCircle.style.width = '50px';
            if (sum === 1) sumCircle.classList.add('active');
            outputContainer.appendChild(sumCircle);

            const coutCircle = document.createElement('div');
            coutCircle.classList.add('circle');
            coutCircle.innerText = 'Cout';
            coutCircle.style.width = '50px';
            if (cout === 1) coutCircle.classList.add('active');
            outputContainer.appendChild(coutCircle);
        }

        function update3BitAdder() {
            const a = parseInt(document.getElementById('a_3bit').value);
            const b = parseInt(document.getElementById('b_3bit').value);
            const sum = a + b;

            // Update binary circles
            updateBinaryCircles('a_3bit_bin', a, 3);
            updateBinaryCircles('b_3bit_bin', b, 3);
            updateBinaryCircles('sum_3bit_bin', sum, 4);

            document.getElementById('sum_3bit_dec').innerText = sum;
        }

        function updateBinaryCircles(containerId, value, bits) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            const binary = value.toString(2).padStart(bits, '0');

            for (let i = 0; i < bits; i++) {
                const circle = document.createElement('div');
                circle.classList.add('circle');
                circle.innerText = binary[i];
                if (binary[i] === '1') {
                    circle.classList.add('active');
                }
                container.appendChild(circle);
            }
        }

        function update4BitSubtractor() {
            const a = parseInt(document.getElementById('a_sub').value);
            const b = parseInt(document.getElementById('b_sub').value);

            // Convert a and b to their 4-bit two's complement binary representation
            const a_twos_comp = (a < 0) ? (a + 16) : a; // Handle negative values for a
            const b_twos_comp = (b < 0) ? (b + 16) : b; // Handle negative values for b

            // Two's complement subtraction: A - B = A + (~B + 1)
            const b_twos_comp_neg = (~b_twos_comp & 0b1111) + 1; // Two's complement negation of B
            const result = a_twos_comp + b_twos_comp_neg;

            updateBinaryCircles('a_sub_bin', a_twos_comp, 4);
            updateBinaryCircles('b_sub_bin', b_twos_comp, 4);
            updateBinaryCircles('b_twos_comp_bin', b_twos_comp_neg & 0b1111, 4);

            const carryOut = (result >> 4) & 0b1;
            const fourBitResult = result & 0b1111;

            // Interpret 4-bit result as signed number (2’s complement)
            const signedResult = (fourBitResult & 0b1000) ? fourBitResult - 16 : fourBitResult;

            updateBinaryCircles('sub_result_carry', carryOut, 1);       // 1-bit carry
            updateBinaryCircles('sub_result_value', fourBitResult, 4);  // 4-bit result

            document.getElementById('sub_result_dec').innerText = signedResult;

            // Overflow detection
            const a_sign = (a_twos_comp & 0b1000) >> 3; // MSB of A
            const b_sign = (b_twos_comp_neg & 0b1000) >> 3; // MSB of -B
            const result_sign = (fourBitResult & 0b1000) >> 3; // MSB of result

            const overflow = (a_sign === b_sign) && (a_sign !== result_sign);
            const overflowContainer = document.getElementById('overflow_detect');
            overflowContainer.innerHTML = overflow ? '<b style="color: red;">⚠️ Phát Hiện Tràn Số - Overflow Detected</b>' : '';
        }

        function updateAdderSubtractor() {
            const a = parseInt(document.getElementById('a_as').value);
            const b = parseInt(document.getElementById('b_as').value);
            const isSubtract = document.getElementById('mode_as').checked;

            // Convert inputs to 4-bit two's complement representation
            const a_twos_comp = (a < 0) ? (a + 16) : a;
            const b_twos_comp = (b < 0) ? (b + 16) : b;

            let b_effective = b_twos_comp;

            if (isSubtract) {
                document.getElementById('b_as_twos_label').style.display = 'block';
                document.getElementById('b_as_twos').style.display = 'flex'; // Show two's complement of B
                b_effective = (~b_twos_comp & 0b1111) + 1; // Two's complement negation of B
            } else {
                // not displaying the two's complement of B when adding
                document.getElementById('b_as_twos_label').style.display = 'none';
                document.getElementById('b_as_twos').style.display = 'none';
            }

            const result = a_twos_comp + b_effective;
            const carryOut = (result >> 4) & 0b1;
            const result4bit = result & 0b1111;
            const signedResult = (result4bit & 0b1000) ? result4bit - 16 : result4bit;

            // Update displays
            updateBinaryCircles('a_as_bin', a_twos_comp, 4);
            updateBinaryCircles('b_as_bin', b_twos_comp, 4);
            updateBinaryCircles('b_as_twos', isSubtract ? b_effective & 0b1111 : 0, 4);
            updateBinaryCircles('as_carry', carryOut, 1);
            updateBinaryCircles('as_result_bin', result4bit, 4);

            document.getElementById('as_result_dec').innerText = signedResult;

            // Overflow detection
            const a_sign = (a_twos_comp & 0b1000) >> 3; // MSB of A
            const b_sign = (b_effective & 0b1000) >> 3; // MSB of B (or -B if subtracting)
            const result_sign = (result4bit & 0b1000) >> 3; // MSB of result

            const overflow = (a_sign === b_sign) && (a_sign !== result_sign);
            const overflowContainer = document.getElementById('overflow_detect_as');
            overflowContainer.innerHTML = overflow ? '<b style="color: red;">⚠️ Phát Hiện Tràn Số - Overflow Detected</b>' : '';
        }

        function initializeOutputs() {
            decode2to4();
            decode2to4Enable();
            decode3to8();
            decode3to8Enable();
            priorityEncode8to3();
            updateMuxCircles();
            updateMuxOutput();
            startMuxInputOscillation();
            updateDemuxOutput();
            startDemuxInputOscillation();
            updateFullAdder();
            update3BitAdder();
            update4BitSubtractor();
            updateAdderSubtractor();
        }

        // ====== First Bar (manual control) ======
        const binaryBar1 = document.getElementById('binaryBar1');
        const numBits = 3;
        let value1 = 0;

        for (let i = numBits - 1; i >= 0; i--) {
            const bit = document.createElement('div');
            bit.className = 'bit';
            bit.id = 'bit1_' + i;
            bit.textContent = '0';
            binaryBar1.appendChild(bit);
        }

        function updateBar1() {
            for (let i = 0; i < numBits; i++) {
                const bit = document.getElementById('bit1_' + i);
                if (value1 & (1 << i)) {
                    bit.textContent = '1';
                    bit.style.backgroundColor = 'lightgreen';
                } else {
                    bit.textContent = '0';
                    bit.style.backgroundColor = 'white';
                }
            }
            const percentage = (value1 / 7) * 100;
            document.getElementById('progressFill1').style.width = percentage + '%';
            document.getElementById('decimalValue1').textContent = value1;
        }

        function increase() {
            value1++;
            if (value1 > 7) {
                value1 = 0;
            }
            updateBar1();
        }

        updateBar1();

        // ====== Second Bar (4-bit signed) ======
        const binaryBar2 = document.getElementById('binaryBar2');
        const numBits2 = 4;
        let value2 = 0; // Range: -8 to 7

        for (let i = numBits2 - 1; i >= 0; i--) {
            const bit = document.createElement('div');
            bit.className = 'bit';
            bit.id = 'bit2_' + i;
            bit.textContent = '0';
            binaryBar2.appendChild(bit);
        }

        function updateBar2() {
            let binary = (value2 < 0 ? (value2 + 16) : value2).toString(2).padStart(5, '0');

            for (let i = 0; i < numBits2; i++) {
                const bit = document.getElementById('bit2_' + i);
                bit.textContent = binary.charAt(4 - i);
                bit.style.backgroundColor = (binary.charAt(4 - i) === '1') ? 'lightgreen' : 'white';
            }

            const progressFill2 = document.getElementById('progressFill2');
            const percentage = Math.abs(value2) / 8 * 100;

            if (value2 >= 0) {
                progressFill2.style.backgroundColor = 'lightgreen';
                progressFill2.style.width = percentage + '%';
            } else {
                progressFill2.style.backgroundColor = 'lightcoral';
                progressFill2.style.width = percentage + '%';
            }

            document.getElementById('decimalValue2').textContent = value2;
        }

        function increase2() {
            value2++;
            if (value2 > 7) {
                value2 = -8;
            }
            updateBar2();
        }

        updateBar2();
    </script>

</body>

</html>
