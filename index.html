<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combinational Functional Blocks</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }

        header {
            background-color: #4CAF50;
            /* color: white; */
            text-align: center;
            padding: 1em;
        }

        section {
            padding: 20px;
            background-color: white;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #333;
        }

        .decoder {
            margin-bottom: 40px;
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .input-group,
        .output {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: gray;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
        }

        .active {
            background-color: limegreen;
        }

        img.circuit {
            max-width: 150px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        img.circuit-large {
            max-width: 250px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        img.circuit-larger {
            max-width: 350px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        img.truth-table {
            max-width: 400px;
        }

        img.truth-table-large {
            max-width: 600px;
        }

        img.truth-table-larger {
            max-width: 700px;
        }
    </style>
</head>

<body onload="initializeOutputs()">

    <header>
        <h1>Combinational Functional Blocks</h1>
        <h2>Mạch Tư Duy Chức Năng</h2>
    </header>

    <section id="intro">
        <p>Mạch tư duy tổ hợp là loại mạch điện tử trong đó đầu ra của mạch là một hàm tư duy trực
            tiếp của các đầu vào tại cùng thời điểm.</p>
        <p>Đặc điểm chính của mạch tư duy tổng hợp:</p>
        <ul>
            <li>Được xây dựng từ các mạch tư duy cơ bản như: AND, OR, NOT, NAND, NOR, XOR, XNOR</li>
            <li>Đầu ra thay đổi ngay lập tức khi đầu vào thay đổi</li>
            <li>Không có bộ nhớ (memoryless)</li>
        </ul>
        <h2>Combinational Functional Blocks- Mạch Tư Duy Chức Năng</h2>
        <p>Mạch chức năng được tạo nên từ mạch tư duy tổ hợp thông dụng gồm:</p>
        <ul>
            <li>Các bộ giải mã (decoder)</li>
            <li>Các bộ mã hóa (encoder)</li>
            <li>Bộ chọn hay bộ điều kênh (multiplexer)</li>
            <li>Bộ phân tách hay bộ phân kênh (demultiplexer)</li>
            <li>Các mạch tính toán số học như bộ cộng, bộ trừ</li>
        </ul>
    </section>

    <section id="decoding">
        <h1>Decoder Circuits</h1>
        <p>Mạch giải mã (Decoder) là một loại mạch điện tử có chức năng chuyển đổi tín hiệu số đầu vào nhị phân (0: 00,
            1: 01, 2: 10, 3: 11) thành một
            dạng tín hiệu đầu ra riêng biệt (1000, 0100, 0010, 0001). Thông thường, mạch giải mã nhận vào n bit dữ liệu
            và kích hoạt đúng một
            trong số 2^n đầu ra dựa trên tổ hợp giá trị của các bit đầu vào.</p>
        <p>Mạch giải mã thường được sử dụng trong các ứng dụng như:</p>
        <ul>
            <li>Lựa chọn đường truyền trong bộ nhớ (memory addressing)</li>
            <li>Điều các thiết bị hiển thị (như LED, màn hình)</li>
        </ul>
        <p>Một số loại mạch giải mã phổ biến bao gồm:</p>
        <ul>
            <li>Mạch giải mã 2-ra-4 (2-to-4 decoder)</li>
            <li>Mạch giải mã 3-ra-8 (3-to-8 decoder)</li>
            <li>Mạch giải mã 4-ra-16 (4-to-16 decoder)</li>
        </ul>
        <p>Thông thường, mạch giải mã có thể có thêm chân <b>Enable</b> để bật hoặc tắt toàn bộ chức năng giải mã theo
            yêu cầu.
        </p>
        <h2>2-to-4 Line Decoder (No Enable)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>A <input type="checkbox" id="a_2to4" onchange="decode2to4()"></label>
                <label>B <input type="checkbox" id="b_2to4" onchange="decode2to4()"></label>
            </div>
            <img src="decode2to4.png" alt="2-to-4 Decoder without Enable" class="circuit">
            <div id="output_2to4" class="output"></div>
        </div>
        <img src="2_4_decoder_tb.jpg" alt="2-to-4 Decoder Truth Table" class="truth-table">

        <h2>2-to-4 Line Decoder (With Enable)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>EN <input type="checkbox" id="enable_2to4" onchange="decode2to4Enable()"></label>
                <label>A <input type="checkbox" id="a_2to4_en" onchange="decode2to4Enable()"></label>
                <label>B <input type="checkbox" id="b_2to4_en" onchange="decode2to4Enable()"></label>
            </div>
            <img src="decode2to4Enable.png" alt="2-to-4 Decoder with Enable" class="circuit-large">
            <div id="output_2to4_en" class="output"></div>
        </div>
        <img src="2-4withEn_tb.png" alt="2-to-4 Decoder with Enable Truth Table" class="truth-table-large">

        <h2>3-to-8 Line Decoder (No Enable)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>A <input type="checkbox" id="a_3to8" onchange="decode3to8()"></label>
                <label>B <input type="checkbox" id="b_3to8" onchange="decode3to8()"></label>
                <label>C <input type="checkbox" id="c_3to8" onchange="decode3to8()"></label>
            </div>
            <img src="decode3to8.png" alt="3-to-8 Decoder without Enable" class="circuit-larger">
            <div id="output_3to8" class="output"></div>
        </div>
        <img src="3_8_decoder_tb.jpg" alt="3-to-8 Decoder Truth Table" class="truth-table-larger">

        <h2>3-to-8 Line Decoder (With Enable)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>EN <input type="checkbox" id="enable_3to8" onchange="decode3to8Enable()"></label>
                <label>A <input type="checkbox" id="a_3to8_en" onchange="decode3to8Enable()"></label>
                <label>B <input type="checkbox" id="b_3to8_en" onchange="decode3to8Enable()"></label>
                <label>C <input type="checkbox" id="c_3to8_en" onchange="decode3to8Enable()"></label>
            </div>
            <img src="decode3to8Enable.png" alt="3-to-8 Decoder with Enable" class="circuit-large">
            <div id="output_3to8_en" class="output"></div>
        </div>
    </section>

    <section id="encoding">
        <h1>Encoder Circuits</h1>
        <p>Mạch mã hóa (Encoder) là một mạch điện tử có chức năng trái ngược với mạch giải mã (Decoder). Nó được dùng để
            mã hóa các tính hiệu đầu vào thành tính hiệu số nhị
            phân đầu ra.Thông thường, một mạch mã hóa có 2<sup>n</sup> đầu vào và n đầu ra. Ví dụ, một mạch mã hóa 8-3
            sẽ có 8 tín hiệu đầu vào và 3 tín hiệu đầu ra, biểu diễn mã nhị phân của đầu vào đang được kích hoạt.</p>
        <p>Tuy nhiên, trong thực tế, có thể xảy ra trường hợp nhiều đầu vào cùng được kích hoạt cùng lúc. Để xử lý vấn
            đề này, người ta thiết kế <b>mạch mã hóa ưu tiên (Priority Encoder)</b>. Trong mạch mã hóa ưu tiên, nếu có
            nhiều
            đầu vào đồng thời ở mức "1", mạch sẽ tự động ưu tiên tín hiệu đầu vào có thứ tự cao hơn</p>
        <p>Ngoài ra, nhiều mạch mã hóa còn bổ sung một đầu ra đặc biệt gọi là chân <b>Validity (V)</b>, hay còn gọi là
            chân hợp
            lệ. Chân này có nhiệm vụ báo hiệu rằng có ít nhất một đầu vào đang được kích hoạt. Nếu tất cả các đầu vào
            đều ở mức "0", chân V sẽ ở mức "0" để báo rằng không có đầu vào hợp lệ; ngược lại, nếu có đầu vào được kích
            hoạt, chân V sẽ ở mức "1".</p>

        <p>Ứng dụng của mạch mã hóa:</p>
        <ul>
            <li>Bàn phím số: Khi một phím được nhấn, mạch mã hóa sẽ chuyển tín hiệu từ phím đó thành mã nhị phân
                gửi cho bộ xử lý.</li>
            <li>Xử lý tính hiệu cảm biến: Trong các hệ thống cảm biến, mạch mã hóa được sử dụng để đọc vị trí,
                tốc độ hoặc các trạng thái khác.</li>
            <li>Thiết kế hệ thống giao tiếp số: Giảm số lượng dây dẫn cần thiết khi truyền tải nhiều tín hiệu.
            </li>
        </ul>

        <h2>8-to-3 Priority Encoder (with Valid Output)</h2>
        <div class="decoder">
            <div class="input-group">
                <label>D0 <input type="checkbox" id="d0_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D1 <input type="checkbox" id="d1_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D2 <input type="checkbox" id="d2_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D3 <input type="checkbox" id="d3_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D4 <input type="checkbox" id="d4_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D5 <input type="checkbox" id="d5_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D6 <input type="checkbox" id="d6_8to3p" onchange="priorityEncode8to3()"></label>
                <label>D7 <input type="checkbox" id="d7_8to3p" onchange="priorityEncode8to3()"></label>
            </div>
            <img src="8_3_p_encoder_V.png" alt="8-to-3 Priority Encoder Circuit" class="circuit-larger">
            <div id="output_8to3p" class="output"></div>
        </div>
        <img src="encoder8to3tb.png" alt="8-to-3 Encoder Truth Table" class="truth-table-large">

    </section>

    <section id="multiplexer">
        <h1>Multiplexer Circuits</h1>
        <p>Bộ chọn hay bộ điều kênh (Multiplexer - viết tắt là MUX) là một loại mạch có chức năng chọn một trong nhiều
            tín hiệu đầu vào để truyền ra một đầu ra duy nhất. Mục tiêu của bộ chọn là gộp nhiều nguồn dữ liệu vào một
            đường truyền chung, từ đó giúp tiết kiệm số lượng dây dẫn và tối ưu hóa hệ thống mạch.</p>

        <p>Một bộ chọn thông thường có:
        <ul>
            <li>2<sup>n</sup> đầu vào dữ liệu (data inputs),</li>
            <li>n đầu vào chọn (select inputs) để xác định đầu vào nào sẽ được kết nối tới đầu ra,</li>
            <li>và 1 đầu ra duy nhất (output).</li>
        </ul>
        </p>

        <p>Ví dụ: Một bộ chọn 4-1 có 4 đầu vào dữ liệu (D0, D1, D2, D3), 2 đầu vào chọn (S1, S0), và 1 đầu ra (Y). Các
            đầu vào chọn S1, S0 sẽ quyết định tín hiệu từ đầu vào nào sẽ xuất hiện tại đầu ra, D0 hoặc D1 hoặc D2 hoặc
            D3.</p>

        <h2>4-to-1 Multiplexer</h2>
        <div class="decoder">
            <div class="input-group">
                <label>S0 <input type="checkbox" id="s0_mux" onchange="updateMuxOutput()"></label>
                <label>S1 <input type="checkbox" id="s1_mux" onchange="updateMuxOutput()"></label>
            </div>
            <div id="input_mux" class="output"></div>
            <img src="mux4to1.png" alt="4-to-1 Multiplexer" class="circuit-large">
            <div id="output_mux" class="output"></div>
            <div id="selected_input_label" style="text-align:center; margin-top:10px; font-weight:bold;"></div>
        </div>
        <img src="mux4to1tb.png" alt="4-to-1 Truth Table" style="max-width: 300px;">

        <h2>4-to-1 Multiplexer Logic Diagram</h2>
        <img src="mux4to1diag.png" alt="4-to-1 Multiplexer Diagram" style="max-width: 500px;">
    </section>

    <section id="demultiplexer">
        <h1>Demultiplexer Circuits</h1>
        <p>Bộ phân tách hay bộ phân kênh (Demultiplexer - viết tắt là DEMUX) là một loại mạch tổ hợp trong điện tử số,
            có chức năng nhận
            một tín hiệu đầu vào và phân phối tín hiệu đó tới một trong nhiều đầu ra. Bộ phân kênh thực hiện quá trình
            ngược lại so với bộ chọn (Multiplexer).</p>

        <p>Một bộ phân kênh thông thường có:
        <ul>
            <li>1 đầu vào dữ liệu (Data Input),</li>
            <li>n đầu vào chọn (Select Inputs) để quyết định tín hiệu sẽ được gửi đến đầu ra nào,</li>
            <li>và 2<sup>n</sup> đầu ra (Outputs).</li>
        </ul>
        </p>

        <p>Ví dụ: Một bộ phân kênh 1-4 có 1 đầu vào dữ liệu (D), 2 đầu vào chọn (S1, S0), và 4 đầu ra (Y0, Y1, Y2, Y3).
            Các tín hiệu tại đầu vào chọn S1 và S0 sẽ xác định đầu ra nào nhận dữ liệu từ đầu vào, D0 hoặc D1 hoặc D2
            hoặc
            D3.</p>

        <h2>1-to-4 Demultiplexer</h2>
        <div class="decoder">
            <div class="input-group">
                <label>S0 <input type="checkbox" id="s0_demux" onchange="updateDemuxOutput()"></label>
                <label>S1 <input type="checkbox" id="s1_demux" onchange="updateDemuxOutput()"></label>
            </div>
            <div id="input_demux" class="output"></div>
            <img src="demux1to4.png" alt="1-to-4 Demultiplexer" class="circuit-large">
            <div id="output_demux" class="output"></div>
        </div>
        
        <h2>1-to-4 Demultiplexer Logic Diagram</h2>
        <img src="demux1to4diag.png" alt="1-to-4 Demultiplexer Diagram" style="max-width: 300px;">
    </section>

    <script>
        function updateCircles(containerId, activeIndex, totalOutputs) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            for (let i = 0; i < totalOutputs; i++) {
                const circle = document.createElement('div');
                circle.classList.add('circle');
                circle.innerText = i;
                if (i === activeIndex) {
                    circle.classList.add('active');
                }
                container.appendChild(circle);
            }
        }

        function decode2to4() {
            let a = document.getElementById('a_2to4').checked ? 1 : 0;
            let b = document.getElementById('b_2to4').checked ? 1 : 0;
            let index = (b << 1) | a;
            updateCircles('output_2to4', index, 4);
        }

        function decode2to4Enable() {
            let enable = document.getElementById('enable_2to4').checked;
            let a = document.getElementById('a_2to4_en').checked ? 1 : 0;
            let b = document.getElementById('b_2to4_en').checked ? 1 : 0;
            if (enable) {
                let index = (b << 1) | a;
                updateCircles('output_2to4_en', index, 4);
            } else {
                updateCircles('output_2to4_en', -1, 4);
            }
        }

        function decode3to8() {
            let a = document.getElementById('a_3to8').checked ? 1 : 0;
            let b = document.getElementById('b_3to8').checked ? 1 : 0;
            let c = document.getElementById('c_3to8').checked ? 1 : 0;
            let index = (c << 2) | (b << 1) | a;
            updateCircles('output_3to8', index, 8);
        }

        function decode3to8Enable() {
            let enable = document.getElementById('enable_3to8').checked;
            let a = document.getElementById('a_3to8_en').checked ? 1 : 0;
            let b = document.getElementById('b_3to8_en').checked ? 1 : 0;
            let c = document.getElementById('c_3to8_en').checked ? 1 : 0;
            if (enable) {
                let index = (c << 2) | (b << 1) | a;
                updateCircles('output_3to8_en', index, 8);
            } else {
                updateCircles('output_3to8_en', -1, 8);
            }
        }

        function priorityEncode8to3() {
            let inputs = [
                document.getElementById('d0_8to3p').checked,
                document.getElementById('d1_8to3p').checked,
                document.getElementById('d2_8to3p').checked,
                document.getElementById('d3_8to3p').checked,
                document.getElementById('d4_8to3p').checked,
                document.getElementById('d5_8to3p').checked,
                document.getElementById('d6_8to3p').checked,
                document.getElementById('d7_8to3p').checked
            ];
            let outputDiv = document.getElementById('output_8to3p');
            outputDiv.innerHTML = '';

            // Priority: D7 highest to D0 lowest
            let activeIndex = -1;
            for (let i = 7; i >= 0; i--) {
                if (inputs[i]) {
                    activeIndex = i;
                    break;
                }
            }

            let labels = ['A2', 'A1', 'A0', 'V'];
            if (activeIndex >= 0) {
                let binary = activeIndex.toString(2).padStart(3, '0');
                // Output circles for A2, A1, A0, V
                for (let i = 0; i < 3; i++) {
                    const circle = document.createElement('div');
                    circle.classList.add('circle');
                    circle.innerText = labels[i];
                    if (binary[2 - i] === '1') {
                        circle.classList.add('active');
                    }
                    outputDiv.appendChild(circle);
                }
                // Add V = 1
                const vCircle = document.createElement('div');
                vCircle.classList.add('circle', 'active');
                vCircle.innerText = labels[3];
                outputDiv.appendChild(vCircle);
            } else {
                // No active input
                for (let i = 0; i < 3; i++) {
                    const circle = document.createElement('div');
                    circle.classList.add('circle');
                    circle.innerText = labels[i];
                    outputDiv.appendChild(circle);
                }
                const vCircle = document.createElement('div');
                vCircle.classList.add('circle');
                vCircle.innerText = labels[3];
                outputDiv.appendChild(vCircle);
            }
        }

        let muxInputs = [0, 0, 0, 0];

        function startMuxInputOscillation() {
            setInterval(() => {
                muxInputs[0] ^= 1;
                updateMuxCircles();
                updateMuxOutput();
            }, 2000); // 0.5 Hz

            setInterval(() => {
                muxInputs[1] ^= 1;
                updateMuxCircles();
                updateMuxOutput();
            }, 500); // 1 Hz

            setInterval(() => {
                muxInputs[2] ^= 1;
                updateMuxCircles();
                updateMuxOutput();
            }, 250);

            setInterval(() => {
                muxInputs[3] ^= 1;
                updateMuxCircles();
                updateMuxOutput();
            }, 50);
        }

        function updateMuxCircles(selected = -1) {
            const inputContainer = document.getElementById('input_mux');
            inputContainer.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const circle = document.createElement('div');
                circle.classList.add('circle');
                circle.innerText = 'I' + i;
                if (muxInputs[i] === 1) {
                    circle.classList.add('active');
                }
                if (i === selected) {
                    //circle.style.backgroundColor = 'deepskyblue'; // Highlight selected input
                    circle.style.color = 'white';
                    circle.style.border = '6px solid red';
                }
                inputContainer.appendChild(circle);
            }
        }

        function updateMuxOutput() {
            let s1 = document.getElementById('s1_mux').checked ? 1 : 0;
            let s0 = document.getElementById('s0_mux').checked ? 1 : 0;
            let selectedInput = (s1 << 1) | s0;
            const yValue = muxInputs[selectedInput];

            const outputContainer = document.getElementById('output_mux');
            outputContainer.innerHTML = '';
            const yCircle = document.createElement('div');
            yCircle.classList.add('circle');
            yCircle.innerText = 'Y';
            if (yValue === 1) {
                yCircle.classList.add('active');
            }
            outputContainer.appendChild(yCircle);

            const selectedLabel = document.getElementById('selected_input_label');
            selectedLabel.innerText = `Selected input: I${selectedInput}`;

            updateMuxCircles(selectedInput); // <-- Pass selected input to highlight
        }

        

        let demuxInput = 0;

        function startDemuxInputOscillation() {
            setInterval(() => {
                demuxInput ^= 1;
                updateDemuxOutput();
            }, 250); // 2 Hz => toggle every 0.5s
        }

        function updateDemuxOutput() {
            let s1 = document.getElementById('s1_demux').checked ? 1 : 0;
            let s0 = document.getElementById('s0_demux').checked ? 1 : 0;
            let selectedOutput = (s1 << 1) | s0;

            // Update Input D
            const inputContainer = document.getElementById('input_demux');
            inputContainer.innerHTML = '';
            const dCircle = document.createElement('div');
            dCircle.classList.add('circle');
            dCircle.innerText = 'D';
            if (demuxInput === 1) {
                dCircle.classList.add('active');
            }
            inputContainer.appendChild(dCircle);

            // Update Outputs Y0, Y1, Y2, Y3
            const outputContainer = document.getElementById('output_demux');
            outputContainer.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const circle = document.createElement('div');
                circle.classList.add('circle');
                circle.innerText = 'Y' + i;
                if (i === selectedOutput && demuxInput === 1) {
                    circle.classList.add('active');
                }
                outputContainer.appendChild(circle);
            }
        }

        function initializeOutputs() {
            decode2to4();
            decode2to4Enable();
            decode3to8();
            decode3to8Enable();
            priorityEncode8to3();
            updateMuxCircles();
            updateMuxOutput();
            startMuxInputOscillation();
            updateDemuxOutput();
            startDemuxInputOscillation();
        }
    </script>

</body>

</html>
